
import net.ltgt.gradle.errorprone.CheckSeverity

plugins {
  id 'com.diffplug.spotless' version '5.9.0'
  id 'com.github.ben-manes.versions' version '0.36.0'
  id 'com.github.hierynomus.license' version '0.15.0'
  id 'io.spring.dependency-management' version '1.0.11.RELEASE'
  id 'net.ltgt.errorprone' version '1.3.0'
  id 'maven-publish'
  id 'java'
  id 'distribution'
}

group = "com.octopus.teamcity"
defaultTasks 'build', 'checkLicenses', 'javadoc'

ext {
  teamcity_version = 10.0
  teamcity_distribution = "C:\\TeamCity"
  build_timestamp_format = "yyyyMMddHHmm"
}

def buildAliases = ['dev': [
    //'spotlessApply',
    'build',
    'checkLicenses',
    'javadoc'
  ]]



allprojects {
  apply plugin: 'java-library'
  apply plugin: 'java'
  apply plugin: 'io.spring.dependency-management'
  apply plugin: 'net.ltgt.errorprone'
  apply from: "${rootDir}/gradle/versions.gradle"
  apply from: "${rootDir}/gradle/check-licenses.gradle"

  // Provided configuration allows compile-time only dependences to NOT
  // be included in the final distributions.
  configurations {
    provided
  }

  // this ensures SNAPSHOT versions are always pulled from maven repo (rather than using past
  // cached version)
  configurations.all {
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
  }

  sourceSets {
    main { compileClasspath += configurations.provided }
  }

  version = rootProject.version

  task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
  }

  task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
  }

  sourceCompatibility = 11
  targetCompatibility = 11

  repositories {
    mavenCentral()
    maven { url "https://download.jetbrains.com/teamcity-repository" }
    maven { url 'https://packages.octopushq.com/artifactory/maven' }
  }

  dependencies {
    errorprone "com.google.errorprone:error_prone_core"
    errorproneJavac("com.google.errorprone:javac:9+181-r4173-1")
  }



  apply plugin: 'com.diffplug.spotless'
  spotless {
    java {
      // This path needs to be relative to each project
      target fileTree('.') {
        include '**/src/*/java/**/*.java'
        exclude '**/.gradle/**'
      }
      removeUnusedImports()
      googleJavaFormat('1.7')
      importOrder 'org.hyperledger', 'java', ''
      trimTrailingWhitespace()
      endWithNewline()
    }

    groovyGradle {
      target '*.gradle'
      greclipse().configFile(rootProject.file('gradle/formatter.properties'))
      endWithNewline()
    }

    // Below this line are currently only license header tasks
    format 'groovy', { target '**/src/*/grovy/**/*.groovy' }
  }

  tasks.withType(JavaCompile) {
    options.compilerArgs += [
      '-Xlint:unchecked',
      '-Xlint:cast',
      '-Xlint:rawtypes',
      '-Xlint:overloads',
      '-Xlint:divzero',
      '-Xlint:finally',
      '-Xlint:static',
      '-Werror',
    ]

    options.errorprone {
      excludedPaths = '.*generated/*.*'

      // Our equals need to be symmetric, this checker doesn't respect that.
      check('EqualsGetClass', CheckSeverity.OFF)
      // We like to use futures with no return values.
      check('FutureReturnValueIgnored', CheckSeverity.OFF)
      // We use the JSR-305 annotations instead of the Google annotations.
      check('ImmutableEnumChecker', CheckSeverity.OFF)
      // This is a style check instead of an error-prone pattern.
      check('UnnecessaryParentheses', CheckSeverity.OFF)

      // This check is broken in Java 12.  See https://github.com/google/error-prone/issues/1257
      if (JavaVersion.current() == JavaVersion.VERSION_12) {
        check('Finally', CheckSeverity.OFF)
      }
      // This check is broken after Java 12.  See https://github.com/google/error-prone/issues/1352
      if (JavaVersion.current() > JavaVersion.VERSION_12) {
        check('TypeParameterUnusedInFormals', CheckSeverity.OFF)
      }

      check('FieldCanBeFinal', CheckSeverity.WARN)
      check('InsecureCryptoUsage', CheckSeverity.WARN)
      check('WildcardImport', CheckSeverity.WARN)
    }

    options.encoding = 'UTF-8'
  }
}


apply plugin: "distribution"


distZip {
  archiveName = "Octopus.TeamCity." + rootProject.version + ".zip"
}

distributions {
  main {
    contents {
      from file("teamcity-plugin.xml"), {
        filter(org.apache.tools.ant.filters.ReplaceTokens, tokens:[version: rootProject.version])
      }
      into('agent/') {
        //from tasks.findByPath(":octopus-agent:distZip").outputs.files
        from tasks.findByPath(":octopus-agent:distZip")
      }
      into('server/') {
        from tasks.findByPath(":octopus-server:installDist")
      }
      into '/'
    }
  }
}

/**
 * Tasks to allow for the running up of a TeamCity Server/Agent
 */


def teamCityInstallDir = System.getenv("TEAMCITY_INSTALL_DIR")
def teamCityDataDir = System.getenv("TEAMCITY_DATA_DIR") ?: System.getenv("HOME") + "/.BuildServer"

// Used to deploy the built zip file to the 'global' teamcity install
task deployLocal(type: Copy) {
  into(teamCityDataDir + "/plugins")
  from tasks.findByPath(":distZip")
}

// Used to deploy the server-side JSP files to the 'global' teamcity install
task updateJsp(type: Copy) {
  def subPath = "/webapps/ROOT/plugins/Octopus.TeamCity"

  doFirst() {
    if(teamCityInstallDir == null) {
      throw new GradleException("TEAMCITY_INSTALL_DIR env var not set, unable to copy jsps")
    }
  }

  outputs.upToDateWhen { false }
  into(teamCityInstallDir + subPath)
  from project(":octopus-server").absoluteProjectPath("src/main/resources/buildServerResources")
}

// Creates a team-city data directory in the build area of this project (allowing other tasks to have an controlled
// build area).
task setupTeamCityDirectory(type: Copy) {
  from zipTree("e2e/src/test/resources/teamcity_config.zip")
  from zipTree("e2e/src/test/resources//projects.zip")
  into("plugins/") {
    from tasks.findByPath(":distZip")
  }
  duplicatesStrategy = DuplicatesStrategy.INCLUDE
  into "${buildDir}/tc_datadir"
}

task runSystem {
  dependsOn ":runTeamCityServer"
  dependsOn ":runTeamCityAgent"
}

task stopSystem {
  dependsOn ":stopTeamCityServer"
  dependsOn ":stopTeamCityAgent"

}

task runTeamCityServer(type: Exec) {
  dependsOn ":setupTeamCityDirectory"
  def subPath = "/bin/"

  environment("TEAMCITY_SERVER_OPTS",
    "-Dteamcity.development.mode=true -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5011")
  environment("TEAMCITY_DATA_PATH", tasks.findByPath(":setupTeamCityDirectory").outputs.files.singleFile)

  commandLine teamCityInstallDir + subPath + "teamcity-server.sh", "start"
}

task runTeamCityAgent(type: Exec) {

  def subPath = "/buildAgent/bin/"

  environment("TEAMCITY_AGENT_OPTS", "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5010")
  environment("TEAMCITY_DATA_PATH", tasks.findByPath(":setupTeamCityDirectory").outputs.files.singleFile)

  commandLine teamCityInstallDir + subPath  + "agent.sh", "start"
}

task stopTeamCityServer(type:Exec) {
  def subPath = "/bin/"
  commandLine teamCityInstallDir + subPath + "teamcity-server.sh", "stop"
}

task stopTeamCityAgent(type:Exec) {
  def subPath = "/buildAgent/bin/"
  commandLine teamCityInstallDir + subPath + "agent.sh", "stop"
}
